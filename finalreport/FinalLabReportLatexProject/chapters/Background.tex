%!TEX root = ../Report.tex
\chapter{Background}
\label{background}
This project focuses primarily on the topic of file system mounting. As such, certain aspects should be explained to give the reader some conceptual and technical context before diving into the project details. We will need to define file systems, mounting, and how mounting is accomplished on a Linux machine. The other important aspect of this project revolves around the inner workings of an Android device and it's operating system. So, I will explore Android rooting, Android APKs, and the role of Android init. This will lead us to the topic that ties everything together, which involves kernel modules and the ability to inject desired code into the kernel upon request.
\section{File System}
A file system is comprised of a file volume and supplemental code. The file volume represents the actual contents of the device. File volumes are organized into a hierarchy of directories containing files at the leaf nodes. File systems can be designed in different ways. The Linux file system and Android storage both use ext4 as their design, while Windows uses vfat as it's design. Both Linux and Android have the capability to utilize the vfat design. In fact, Android uses the vfat design for removable disks. \\ \\
Regardless of the design, however, there are operations available. In order to make a file system, the command \verb|mkfs| can be used. To mount an external file volume to an existing directory in the file system, the command \verb|mount| can be used. The existing directory used for mounting is called the mount point. In order to unmount the file volume, simply use the command \verb|umount|. \\ \\
Mounting is an important operation to keep in mind throughout this paper. Mounting makes a new and, usually, remote file volume accessible through an existing, local file volume. As mentioned before, that existing file volume is referred to as the mount point. Any content that already existed within that mount point directory will no longer be accessible while the additional file volume is mounted. Once it is unmounted, then everything within that existing file volume will return and be accessible as it was before. In this way, file volumes can be mounted just about anywhere. As for removable disks, there is a designated mount point that is used. These disks can either be mounted to the \verb|/mnt| directory or a directory within that directory. Many of these operations can only be performed by a root user, an account that has the highest privileges within the system. This will be discussed further in section \ref{androidinternals} below.
\section{Android Internals}
\label{androidinternals}
Upon purchase from the manufacturer, all Android devices are not rooted by default. However, rooting an Android device is an important step needed before many other meaningful actions can be taken on the device, especially at the Operating System level. Rooting a device allows the user to log in as the root user and execute operations with elevated permissions. The Android Debug Bridge (\verb|adb|) is used heavily when rooting an Android device. This is a tool that can be used to interact with the device from a computer using the terminal on the computer and the ip address of the device. This tool is also very useful for installing APKs on Android devices from the computer or performing many other tasks without having to use the terminal on the device itself. \\ \\
An Android Package (APK) is a compressed file which contains the Java code solution for the given application. The extension of the APK file is simply \verb|.apk| versus \verb|.zip|. The device has logic to handle a file with that extension differently than a ZIP file. If a user desires to see the code behind an Android application, he/she can rename the extension of the file to \verb|.zip| and extract the contents in order to explore the code. Another approach is to use the Android Studio application and choose the option to "Profile or Debug APK". The second option is very straightforward and the user can utilize the convenient tools within Android Studio to better explore the code. \\ \\
However, an Android device needs to boot up before it can be rooted or have APKs installed onto it. This is where the program \verb|init| steps in. This program is an important step in the boot process of an Android device. It is responsible for getting the system setup by initializing services in a certain, specified order. It monitors these services and restarts them if they crash, so that they remain running from the start of the system to when it shuts down. It obtains it's instructions from a file called \verb|init.rc|. If the user desired certain commands or applications to execute during the booting of the device, this init file would be the place to specify that instruction. Some applications do not require code execution at boot time, but rather on demand. In this case, kernel modules can be utilized. \cite{pmatetinotes}
\section{Kernel}
Kernel modules make it possible to inject code into the kernel upon request. This helps to avoid attempting to include every imaginable capability into the kernel itself, bloating the kernel as a result. The modular approach allows the user to plug his/her code in when and where desired. Modules are not applications, however. An order of execution cannot be enforced, many processes can be utilizing one module, there is a sensitivity to interruptions of the executing module, and resource cleanup must be manually maintained. This capability still makes it more flexible to allow the user to run certain modules on demand and tailor the experience to his/her specific needs. \cite{kernelmodule}